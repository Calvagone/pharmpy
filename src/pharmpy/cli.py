#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
"""
============================
The CLI interface of PharmPy
============================

Yes, CLI is anticipated to remain the main interface! But... maybe with 16 colors?

Example argument lines (only preceeded by ``pharmpy``, ``python3 -m pharmpy`` or whatever):

    .. list-table::
        :widths: 40 60
        :stub-columns: 1

        - - ``transform --filter --data output.csv``
          - Filters data as model prescribes (``IGNORE`` statements in ``$DATA`` in NONMEM) and
            outputs to new file ``output.csv``.

Old contents of ``../bin/pharmpy`` can be found below. File removed because this file is the
main entrypointof the CLI (and has been for a long time). Might be useful to define more entrypoints
later, but it certainly isn't necessary.

PsN-styled command invokes should ideally be autogenerated to reduce maintaining, and enable myself
to use a non-bloating subcommand-based interface.

.. code ::

    # Warning: hic sunt dracones!
    # This is a superdirty start to test a command line interface
    # or rather to see what code using the API would look like

    import sys
    sys.path.append("..")

    import pharmpy


    if len(sys.argv) < 4:
        sys.exit()

    if sys.argv[1] == 'transform':
        if sys.argv[2] == 'apply_filters':
            model_filename = sys.argv[3]
            model = pharmpy.Model(model_filename)
            model.input.apply_and_remove_filters()
            model.input.path = str(model.input.path) + '.new'
            model.input.write_dataset()

Anyway, the standard practice of Python packaging is (nowadays) to not spread outside the library,
but to define an "entrypoint" in the setuptools ``setup.py``. This currently looks as follows:

.. code ::

    entry_points={
        'console_scripts': [
            'pharmpy = pharmpy.cli:main',
        ]
    },

Which is *this file*.

Also called from ``__main__.py`` because then this works: ``python3 -m pharmpy``. Neat, huh

Definitions
===========
"""

import argparse
import logging
import pathlib
import sys
from textwrap import dedent

import pharmpy
from pharmpy import __version__


class CLI:
    """Manages main CLI interface.

    Idea is that main interface is subcommand-based. As is popular nowadays (see Git!).

    *However...* all subcommands shall be invokable without stepping through :func:`CLI.__init__`,
    and thus easy to install symlinks for (à la PsN). Noth that I would *recommend* it, but...
    """

    def __init__(self, args=None):
        """Initialize and parse command line arguments"""

        # root parser and common arguments
        parser = argparse.ArgumentParser(
            prog='pharmpy',
            description='PharmPy CLI interface',
            epilog='Some/all commands may be symlinked on your install.',
            formatter_class=argparse.RawTextHelpFormatter,
            allow_abbrev=True,
        )
        self._init_common_args(parser)

        # subcommand parsers
        subparsers = parser.add_subparsers(title='PharmPy commands', metavar='COMMAND')
        self._init_commands_tools(subparsers)
        self._init_commands_misc(subparsers)

        # use sys.argv, unless function args supplied (for testing/chaining)
        if args is None:
            self.logger.debug('Parse target: sys.argv=%r', sys.argv)
            args = parser.parse_args()
        else:
            args = [__file__] + list(args)
            self.logger.debug('Parse target: args=%r', args)
            args = parser.parse_args(args)
        self.set_loglevel(args.loglevel)
        if args.hide_traceback:
            self.hide_traceback()

        # dispatch subcommand
        if 'func' in args:
            args.func(args)
        else:
            parser.print_usage()

    # -- additional initializers ---------------------------------------------------------------

    def _init_common_args(self, parser):
        """Initializes common arguments on *parser* and ``self``.

        Groups common to all parsers (activated here)

            .. list-table::
                :widths: 20 80
                :stub-columns: 1

                - - configuration (*proposal*)
                  - To override current (project) configuration file.
                - - logging & verbosity
                  - Sets loglevel and behaviour (e.g. color, file copy, etc.) for all of PharmPy.

        .. note::
            Logging level is set for this, (if CLI) *root*, logger. All other parts of PharmPy
            will get their messages filtered through this.

        Superclasses for some commands (*parents* in :func:`argparse.ArgumentParser.add_parser`)

            .. list-table::
                :widths: 20 80
                :stub-columns: 1

                - - :attr:`self._args_input`
                  - Common arguments for commands reading input (model) files.
                - - :attr:`self._args_output`
                  - Common arguments for commands writing output files.
        """

        # common to: all
        verbosity = parser.add_argument_group(title='logging & verbosity')
        verbosity.add_argument(
            '--hide_traceback',
            action='store_true',
            help="avoid intimidating exception tracebacks",
        )
        loglevel = verbosity.add_mutually_exclusive_group()
        loglevel.add_argument(
            '-v', '--verbose',
            action='store_const', dest='loglevel', const=logging.INFO,
            default=logging.WARNING,
            help='print additional info',
        )
        loglevel.add_argument(
            '-vv', '--debug',
            action='store_const', dest='loglevel', const=logging.DEBUG,
            help='show debug messages',
        )

        # common to: commands with file input
        args_input = argparse.ArgumentParser(add_help=False)
        group_input = args_input.add_argument_group(title='file input')
        group_input.add_argument(
            'input_model', metavar='file', type=pharmpy.Model,
            help='input model file to operate on',
        )
        self._args_input = args_input

        # common to: commands with file output
        args_output = argparse.ArgumentParser(add_help=False)
        group_output = args_output.add_argument_group(title='file output')
        group_output.add_argument('-f', '--force', action='store_true',
                                  help='remove existing destination files (all)')
        group_output.add_argument(
            'output_model', metavar='output', type=pathlib.Path,
            help='output model file to create',
        )
        self._args_output = args_output

    def _init_commands_tools(self, parsers):
        """Initializes all tool subcommands."""

        # -- sumo ------------------------------------------------------------------------------
        sumo = parsers.add_parser('sumo', parents=[self._args_input],
                                  help='Summarize model or run')
        sumo.set_defaults(func=self.sumo)

        # -- clone -----------------------------------------------------------------------------
        clone = parsers.add_parser('clone', parents=[self._args_input, self._args_output],
                                   help='Duplicate model or run')
        clone.add_argument('--ui', '--update_inits', action='store_true',
                           help='set initial estimates (← final estimates)')
        clone.set_defaults(func=self.clone)

        # -- execute ---------------------------------------------------------------------------
        execute = parsers.add_parser('execute', parents=[self._args_input],
                                     help='Execute model task/workflow')
        execute.set_defaults(func=self.execute)

        # -- transform -------------------------------------------------------------------------
        transform = parsers.add_parser('transform', parents=[self._args_input, self._args_output],
                                       help='Common model transformations')
        transform.add_argument('--filter_data', action='store_true',
                               help='apply input data filtering')
        transform.add_argument('--data', dest='output_data', metavar='PATH',
                               type=pathlib.Path, nargs=1,
                               help='set model input data (← PATH); also output of new data')
        transform.set_defaults(func=self.transform)

    def _init_commands_misc(self, parsers):
        """Initializes miscellanelous (other) subcommands."""

        # -- help ------------------------------------------------------------------------------
        help = parsers.add_parser('help', help='PharmPy help central')
        help.set_defaults(func=self.help)
        help.add_argument('search_terms', metavar='term', nargs='*', help='search terms')

        # -- version ---------------------------------------------------------------------------
        version = parsers.add_parser('version', help='Show version information')
        version.set_defaults(func=self.version)

    # -- subcommand launchers ------------------------------------------------------------------

    def help(self, args):
        """Subcommand for built-in help on PharmPy or other subcommand."""

        self.logger.info("PharmPy tool: help")
        raise NotImplementedError("Subcommand not available yet. Working on it!")

    def sumo(self, args):
        """Subcommand for rebooted PsN ``sumo``."""

        self.logger.info("PharmPy tool: sumo")
        raise NotImplementedError("Subcommand not available yet. Working on it!")

    def clone(self, args):
        """Subcommand to clone a model/update initial estimates."""

        self.logger.info("PharmPy tool: clone")
        raise NotImplementedError("Subcommand not available yet. Working on it!")

    def execute(self, args):
        """Subcommand to execute a model default task/workflow."""

        self.logger.info("PharmPy tool: execute")
        raise NotImplementedError("Subcommand not available yet. Working on it!")

    def transform(self, args):
        """Subcommand to transform a model."""

        self.logger.info("PharmPy tool: transform")

        model = args.input_model
        write_model = False
        write_data = False

        # -- model input (data) mutability -----------------------------------------------------
        if args.filter_data:
            model.input.apply_and_remove_filters()
            write_model = True
            write_data = True

        if args.output_data:
            model.input.path = args.output_data.resolve()
            write_model = True

        # -- model input (data) file write -----------------------------------------------------
        if write_data:
            if model.input.path.exists() and not args.force:
                self.logger.warning("If really sure, use '--force'.")
                raise FileExistsError("Would write data but file exists: %r" % str(model.input.path))
            else:
                model.input.write_dataset()

        # -- model file mutability -------------------------------------------------------------
        if args.output_model:
            model.path = args.output_model.resolve()
            write_model = True

        # -- model file write ------------------------------------------------------------------
        if write_model:
            if model.path.exists() and not args.force:
                self.logger.warning("Forgot '--data'? If really sure, use '--force'.")
                raise FileExistsError("Would write model, but file exists: %r" % str(model.path))
            else:
                model.write()

    def version(self, args):
        """Subcommand to print PharmPy version (and brag a little bit)."""

        self.logger.info("PharmPy tool: version")
        text = dedent("""
            Version: %s
            Authors: Gunnar Yngman <gunnar.yngman@farmbio.uu.se>
                     Rikard Nordgren <rikard.nordgren@farmbio.uu.se>
        """ % __version__).strip()
        print(text)

    # -- logging helpers -----------------------------------------------------------------------

    @property
    def logger(self):
        """Returns current CLI logger.

        Initializes, too, if not already configured (= no handlers).

        .. note::
            Logger **mustn't be configurated** if imported as library (e.g. set handlers and such),
            since that should bubble up into the lap of whomever is at the top.

            As a CLI however, we are the top.
        """

        logger = logging.getLogger(__file__)
        if logger.hasHandlers():
            return logger

        msg = logging.StreamHandler(sys.stdout)
        err = logging.StreamHandler(sys.stderr)

        msg.addFilter(lambda record: record.levelno <= logging.INFO)
        err.setLevel(logging.WARNING)

        logger.addHandler(msg)
        logger.addHandler(err)
        self.set_loglevel(logging.NOTSET)

        return logger

    # -- configuration -------------------------------------------------------------------------

    def set_loglevel(self, level):
        """Sets current loglevel (and message formatting)."""

        self.logger.setLevel(level)
        if level <= logging.DEBUG:
            fmt = "%(asctime)s.%(msecs)03d %(filename)-25s %(lineno)4d %(levelname)-8s %(message)s"
            datefmt = "%H:%M:%S"
        else:
            fmt = '%(message)s'
            datefmt = "%Y-%m-%d %H:%M:%S"
        for handler in self.logger.handlers:
            handler.setFormatter(logging.Formatter(fmt, datefmt))

    def hide_traceback(self):
        """Override default exception hook to hide all tracebacks.

        .. note:: Even without traceback, the exception and message is shown.
        """

        def no_traceback(exception_type, exception, traceback):
            self.logger.critical('%s: %s', exception_type.__name__, exception)

        self.logger.debug('Overriding sys.excepthook(=%r) to hide tracebacks (but not exceptions)')
        sys.excepthook = no_traceback


def main(args=None):
    """Invoked by ``__main__.py`` and entry point of binary.

    Use *args* to implement argument parsing from non-standard source (bypasses :attr:`sys.argv`).
    """

    CLI(args)

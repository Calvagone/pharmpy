// A precedence climbing grammar is used for expressions
// The top level has one full line of code per rule

root: _empty_lines? (pseudo _empty_lines?)? _statements_and_verbatims?
_empty_lines: _empty_lines? empty_line
empty_line: WS? COMMENT? NEWLINE

_statements_and_verbatims: _statements_and_verbatims? (statement | verbatim) _empty_lines?
_statements: _statements? statement _empty_lines?

pseudo: WS? PSEUDO_STATEMENT ")" WS? COMMENT? NEWLINE
PSEUDO_STATEMENT: /[(][^)]*/ // NOTE Early's dynamic lexer does not support zero-width regexes

// NOTE trailing NEWLINE needs to be optional in case of EOF
verbatim: WS? VERBATIM_STATEMENT NEWLINE
VERBATIM_STATEMENT: /"[^\n]*/

// NOTE trailing NEWLINE needs to be optional in case of EOF
statement: WS? _statement WS? COMMENT? NEWLINE

_statement: assignment
          | logical_if
          | block_if
          | while
          | exit
          | call
          | return

exit: EXIT (_cont ("1" | "2") | _cont ("1" | "2") _cont SIGNED_INT)?
call: CALL _cont CNAME _cont? "(" _cont? _atoms _cont? ")"
_atoms: (_atoms _cont? "," _cont?)? atom
return: RETURN
assignment: variable _cont? "=" _cont? real_expr

while: DO _cont? WHILE _cont? "(" bool_expr ")" _empty_lines _statements? WS? ENDDO

block_if: block_if_start WS? (block_if_elseif WS?)* (block_if_else WS?)? block_if_end
block_if_start: IF _cont? "(" bool_expr ")" _cont? THEN _empty_lines _statements?
block_if_elseif: ELSE _cont? IF _cont? "(" bool_expr ")" _cont? THEN _empty_lines _statements?
block_if_else: ELSE _empty_lines _statements?
block_if_end: ENDIF

EXIT   : "EXIT"i
CALL   : "CALL"i
RETURN : "RETURN"i
DO     : "DO"i
WHILE  : "WHILE"i
ENDDO  : "END DO"i
IF     : "IF"i
THEN   : "THEN"i
ELSE   : "ELSE"i
ENDIF  : "END IF"i
       | "ENDIF"i

logical_if: IF _cont? "(" _cont? bool_expr _cont? ")" _cont? (assignment | exit | call)
bool_expr: or_expr

?or_expr: and_expr
        | or_expr _cont? lor _cont? and_expr           -> instruction_infix
         // NOTE Left-associativity for logical or

?and_expr: not_expr
         | and_expr _cont? land _cont? not_expr        -> instruction_infix
         // NOTE Left-associativity for logical and

?not_expr: eq_expr
         | lnot _cont? eq_expr                         -> instruction_unary

?eq_expr: rel_expr
        | rel_expr _cont? _eq_op _cont? eq_expr        -> instruction_infix

?rel_expr: real_expr
         | real_expr _cont? _rel_op _cont? real_expr -> instruction_infix

lor: ".OR."i

land: ".AND."i

_eq_op: eq | ne
eq: "==" | ".EQ."i
ne: "/=" | ".NE."i

_rel_op: lt | le | gt | ge
lt: ".LT."i | "<"
le: ".LE."i | "<="
gt: ".GT."i | ">"
ge: ".GE."i | ">="

lnot: ".NOT."i

real_expr: add_expr

?add_expr: mul_expr
         | add_expr _cont? _add_op _cont? mul_expr  -> instruction_infix
         // NOTE Left-associativity for addition and subtraction

?mul_expr: sign_expr
         | mul_expr _cont? _mul_op _cont? sign_expr -> instruction_infix
         // NOTE Left-associativity for multiplication and division

?sign_expr: pow_expr
          | _sign _cont? pow_expr                   -> instruction_unary

?pow_expr: atom
         | atom _cont? pow_op _cont? sign_expr     -> instruction_infix
         // NOTE Right-associativity for exponentiation

_sign: pos_op | neg_op
pos_op: "+"
neg_op: "-"

_add_op: add_op | sub_op
add_op  : "+"
sub_op  : "-"

_mul_op : mul_op | div_op
mul_op  : "*"
div_op  : "/"

pow_op : "**"


?atom: img
     | symbol
     | number
     | "(" _cont? real_expr _cont? ")" -> real_expr

img: _fn1 "(" _cont? real_expr _cont? ")"
   | _fn2 "(" _cont? real_expr _cont? "," _cont? real_expr _cont? ")"

_fn1: exp | pexp
    | log | plog
    | log10 | plog10
    | sqrt | psqrt
    | sin | cos | tan
    | asin | acos | atan
    | abs
    | int
    | loggamma
    | pdz
    | pzr
    | pnp
    | phe
    | png
    | phi

exp: "EXP"i | "DEXP"i
pexp: "PEXP"i
log: "LOG"i
plog: "PLOG"i
log10: "LOG10"i
plog10: "PLOG10"i
sqrt: "SQRT"i
psqrt: "PSQRT"i
sin: "SIN"i
cos: "COS"i
tan: "TAN"i | "PTAN"i
asin: "ASIN"i | "PASIN"i
acos: "ACOS"i | "PACOS"i
atan: "ATAN"i | "PATAN"i
abs: "ABS"i
int: "INT"i
loggamma: "GAMLN"i
pdz: "PDZ"i
pzr: "PZR"i
pnp: "PNP"i
phe: "PHE"i
png: "PNG"i
phi: "PHI"i

_fn2: mod
mod: "MOD"i

variable: vector
        | CNAME

symbol: parameter
      | vector
      | CNAME

vector: CNAME (subscript | double_subscript)
parameter: (THETA | ETA | EPS | OMEGA | SIGMA) subscript
         | (OMEGA | SIGMA) double_subscript

subscript: "(" _cont? (CNAME | SIGNED_INT) _cont? ")"
double_subscript: "(" _cont? SIGNED_INT _cont? "," _cont? SIGNED_INT _cont? ")"

number: SIGNED_INT
      | FLOAT

FLOAT: /[-+]?((\d+\.\d*|\.\d+)([ed][-+]?\d+)?|\d+([ed][-+]?\d+))/i

THETA: "THETA"i

ETA: "ETA"i

EPS: "EPS"i
   | "ERR"i

OMEGA: "OMEGA"i

SIGMA: "SIGMA"i

_cont: WS
     | WS? CONT WS?

CONT: /&[ \x00\t]*\r?\n/

%import .definitions (COMMENT, NEWLINE, WS)
%import common (CNAME, SIGNED_INT)

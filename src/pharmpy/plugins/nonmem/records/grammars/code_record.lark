// A precedence climbing grammar is used for expressions
// The top level has one full line of code per rule

root: _empty_lines? (pseudo _empty_lines?)? _statements?
_empty_lines: _empty_lines? empty_line
empty_line: WS? COMMENT? NEWLINE
_line_ending: (_line_ending WS?)? COMMENT? NEWLINE

_statements: _statements? (statement | verbatim) _empty_lines?

pseudo: WS? PSEUDO_STATEMENT ")" WS? COMMENT? NEWLINE
PSEUDO_STATEMENT: /[(][^)]*/ // NOTE Early's dynamic lexer does not support zero-width regexes

// NOTE trailing NEWLINE needs to be optional in case of EOF
verbatim: WS? VERBATIM_STATEMENT NEWLINE
VERBATIM_STATEMENT: /"[^\n]*/

// NOTE trailing NEWLINE needs to be optional in case of EOF
statement: WS? _statement WS? COMMENT? NEWLINE

_statement: assignment
          | logical_if
          | block_if
          | while
          | exit
          | call
          | return

exit: EXIT (_cont ("1" | "2") | _cont ("1" | "2") _cont SIGNED_INT)?
call: CALL _cont CNAME _cont? "(" _cont? _atoms _cont? ")"
_atoms: (_atoms _cont? "," _cont?)? _atom
return: RETURN
assignment: variable _cont? "=" _cont? expression

while: WS? DO _cont? WHILE _cont? "(" logical_expression ")" WS? _line_ending (WS? statement _empty_lines?)* WS? ENDDO

block_if: block_if_start block_if_elseif* block_if_else? block_if_end
block_if_start: WS? IF _cont? "(" logical_expression ")" _cont? THEN WS? _line_ending (WS? statement _empty_lines?)*
block_if_elseif: WS? ELSE _cont? IF _cont? "(" logical_expression ")" _cont? THEN WS? _line_ending (WS? statement _empty_lines?)*
block_if_else: WS? ELSE WS? _line_ending (WS? statement _empty_lines?)*
block_if_end: WS? ENDIF

EXIT   : "EXIT"i
CALL   : "CALL"i
RETURN : "RETURN"i
DO     : "DO"i
WHILE  : "WHILE"i
ENDDO  : "END DO"i
IF     : "IF"i
THEN   : "THEN"i
ELSE   : "ELSE"i
ENDIF  : "END IF"i
       | "ENDIF"i

logical_if: IF _cont? "(" _cont? logical_expression _cont? ")" _cont? (assignment | exit | call)
?logical_expression: _or_term (_cont? or_op _cont? _or_term)*
_or_term: _and_term (_cont? and_op _cont? _and_term)*
_and_term: (not_op _cont?)? not_term
not_term: _eq_term (_cont? eq_op _cont? _eq_term)? -> logical_expression
_eq_term: _rel_term (_cont? rel_op _cont? _rel_term)?
_rel_term: expression

or_op: ".OR."i                            -> logical_operator

and_op: ".AND."i                          -> logical_operator

eq_op: "=="                               -> logical_operator
     | ".EQ."i                            -> logical_operator
     | "/="                               -> logical_operator
     | ".NE."i                            -> logical_operator

rel_op: ".LT."i                           -> logical_operator
      | "<"                               -> logical_operator
      | ".LE."i                           -> logical_operator
      | "<="                              -> logical_operator
      | ".GT."i                           -> logical_operator
      | ">"                               -> logical_operator
      | ".GE."i                           -> logical_operator
      | ">="                              -> logical_operator

not_op: ".NOT."i                          -> logical_operator

?expression: term (_cont? add_op _cont? term)*
?term: _factor (_cont? mul_op _cont? _factor)* -> expression
_factor: (UNARY_OP _cont?)? (_atom | power)
?power: _atom (_cont? "**" _cont? _factor)?

UNARY_OP: "+"
        | "-"

add_op  : "+" -> operator
        | "-" -> operator
mul_op  : "*" -> operator
        | "/" -> operator


_atom: img
     | symbol
     | number
     | "(" _cont? expression _cont? ")"

img: fn1 "(" _cont? expression _cont? ")"
   | fn2 "(" _cont? expression _cont? "," _cont? expression _cont? ")"

fn1: "LOG"i
   | "LOG10"i
   | "EXP"i
   | "DEXP"i
   | "SQRT"i
   | "SIN"i
   | "COS"i
   | "ABS"i
   | "TAN"i
   | "ASIN"i
   | "ACOS"i
   | "ATAN"i
   | "INT"i
   | "GAMLN"i
   | "PHI"i
   | "PLOG"i
   | "PLOG10"i
   | "PSQRT"i
   | "PEXP"i
   | "PDZ"i
   | "PZR"i
   | "PNP"i
   | "PHE"i
   | "PNG"i
   | "PTAN"i
   | "PATAN"i
   | "PASIN"i
   | "PACOS"i

fn2: "MOD"i

variable: vector
        | CNAME

symbol: parameter
      | vector
      | CNAME

vector: CNAME (subscript | double_subscript)
parameter: (THETA | ETA | EPS | OMEGA | SIGMA) subscript
         | (OMEGA | SIGMA) double_subscript

subscript: _cont? "(" _cont? SIGNED_INT _cont? ")"
         | _cont? "(" _cont? CNAME _cont? ")"
double_subscript: _cont? "(" _cont? SIGNED_INT _cont? "," _cont? SIGNED_INT _cont? ")"

number: SIGNED_INT
      | FLOAT

FLOAT: /[-+]?((\d+\.\d*|\.\d+)([ed][-+]?\d+)?|\d+([ed][-+]?\d+))/i

THETA: "THETA"i

ETA: "ETA"i

EPS: "EPS"i
   | "ERR"i

OMEGA: "OMEGA"i

SIGMA: "SIGMA"i

_cont: WS
     | WS? CONT WS?

CONT: /&[ \x00\t]*\r?\n/

%import .definitions (COMMENT, NEWLINE, WS)
%import common (CNAME, SIGNED_INT)
